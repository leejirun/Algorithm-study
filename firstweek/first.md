#first
문제 풀이 날짜: 2025-03-03(mon)
문제 유형: 브루트포스
문제 레벨: 브론즈2 
문제명: 분해합
문제 링크: https://www.acmicpc.net/problem/2231
정답 여부: 실패

💡문제 분석 요약
1) 문제 예시:
245의 분해합 256 = 245+2+4+5

2) 목표:
주어진 자연수 n의 가장 작은 생성자를 찾기

3) 제약 조건:
*생성자(M)
- 생성자가 없는 수도 있다 -> 정답이 없으면 0 출력하자
- 생성자가 여러 개라면 가장 작은 값을 출력하자.

💡알고리즘 설계
- 분해합의 공식: M+M의 각 자리수의 합 = N
1.for 반복문을 돌려서 1...n 까지 검사
2.각 자리수를 더하기
3.분해합 계산 후 비교
4.끝까지 못 찾으면 0을 출력 

💡코드
`
function findGenerator(N) {
    for (let M=1; M<=N; M++) {
        let sum = M + [...String(M)].reduce((acc, digit) => acc + Number(digit), 0);

        if (sum === N) {
            console.log(M);
            return;
        }
    }
    console.log(0);
}
`

💡개념
1. 브루트포스(Brute-force, 완전 탐색) 접근
가능한 모든 값을 하나씩 대입하며 답을 찾는 방식
이 문제에서는 1부터 N까지 차례로 검사하는 방식으로 이에 해당됨

즉, 특정 숫자 M이 있을 때, sum(M)=M+각 자리수 합을 만족하는 가장 작은 M을 찾아야 함
- 어떤 수의 생성자가 존재할 수도 있고, 없을 수도 있음
- 가장 작은 생성자를 찾아야 하므로, 작은 수부터 탐색해야 함
- 모든 가능성을 고려하는 것이 가장 직관적임

 2. 문자열 변환 후 배열화 
`
let num = 245;
let digits = [...String(num)].map(Number);  // [2, 4, 5]
`
=> String(num): 숫자를 문자열로 변환 ("245")
=> [...String(num)]: 문자열을 배열로 변환 (["2", "4", "5"])
=> .map(Number): 문자형 숫자를 숫자로 변환 ([2, 4, 5])


3.각 자리수 다루는 방법
- N의 생성자인 M을 찾으려면 M의 분해합을 계산해야한다.
M+M의 각 자리수 합을 구하는 것이 핵심인데, 이때 숫자의 각 자리수를 더히는 방법을 고민해야한다.

2가지 방법이 있다.


방법1: 나머지 연산 (%) 사용 
`
let sum = 0, num = M;
while (num > 0) {
    sum += num % 10;  // 마지막 자리수 더하기
    num = Math.floor(num / 10);  // 자리수 줄이기
}
`
=> num % 10: 마지막 자리수 가져오기
=> Math.floor(num / 10): 숫자 줄이기


방법2. reduce()를 사용한 배열 합산
숫자의 자리수를 합할 때 reduce()를 활용하면 코드가 간결해짐
`
let digits = [2, 4, 5];
let sum = digits.reduce((acc, digit) => acc + digit, 0);  // 2 + 4 + 5 = 11
`
=> 동작 과정

초기값 acc = 0
0 + 2 = 2
2 + 4 = 6
6 + 5 = 11

💡 틀린 이유 & 틀린 부분 수정 
- reduce()에서 Number(digit) 변환 안 함
기존 내 코드
`
[...String(M)].reduce((acc, digit) => acc + digit, 0); 
`

수정
`
[...String(M)].reduce((acc, digit) => acc + Number(digit), 0);
`

설명
digit은 문자열이다. 그러므로 "2"+"5"+"6"="256"처럼 됨.
그래서 Number()를 이용해서 형을 바꿔줘서 처리해야함.


💡 다른 풀이 or 기억할정보 

[다른 풀이]
`
function findGenerator(N) {
    for (let M=1; M<=N; M++) {
        let sum = M + [...String(M)].reduce((acc, digit) => acc + Number(digit), 0);

        if (sum === N) {
            console.log(M);
            return;
        }
    }
    console.log(0);
}
`
[정리]
1) 불필요한 탐색을 줄일 수 있다.
- 기존 코드는 1부터 N까지 검사를 한다. 위는 M의 범위를 N-(9*자리수 개수)부터 시작해서 훨씬 적게 탐색을 한다.
- EX) start = 256 - (3 × 9) = 229  , 229부터 탐색하므로 훨씬 빠르다.

2) 시간 복잡도 개선
- 최악의 경우에도 탐색 범위가 N보다 훨씬 작아진다
- 평균적으로 O(N) → O(N의 자리수 크기) 수준으로 줄어듦

3) 문제에 의도에 맞게 생성자 개념을 활용
- 단순 브루트포스가 아니라 자리수 성질을 이용하여 더 빠른 풀이를 진행


💡느낀점 or 기억할 정보
문제를 계속 읽고 고민해봐도 어떻게 시작해야할 지 감이 안잡혔다.
그래서 검색해서 사람들의 풀이 과정을 보며, 나는 어떻게 풀어야 할 지
고민하다가 2-3시간이 훌쩍 가버렸다.
브루트포스의 개념을 알게 되었는데, 새롭게 알게 된 개념이기도 하고 문제의 예시를 보면 알 수 있듯이 분해합은 반드시 생성자보다 크다. 다음에 이 개념을 기억하고 반드시 다시 풀어보도록 해야할 듯하다.