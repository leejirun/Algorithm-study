## 💡문제 분석 요약
1.처음에는 1번 컵에 공이 들어있음
2.두 개의 컵을 교환하는 작업을 여러 번 수행
3.최종적으로 공이 들어 있는 컵의 번호를 출력

## 💡알고리즘 설계
1.공의 위치를 추적하기 위해 배열을 사용
2.초기에는 1번 컵에 공이 있음 (cup[1] = true)
3.M번의 컵 교환을 수행하면서 두 컵의 위치를 바꿈
4.최종적으로 공이 들어 있는 컵의 번호를 출력

## 💡코드
package main

import (
	"fmt"
)

func main() {
	var M int
	fmt.Scan(&M)

	cup := [4]bool{}
	cup[1] = true 

	for i := 0; i < M; i++ {
		var X, Y int
		fmt.Scan(&X, &Y)
		
		cup[X], cup[Y] = cup[Y], cup[X]
	}

	for i := 1; i <= 3; i++ {
		if cup[i] {
			fmt.Println(i)
			break
		}
	}
}


## 💡개념
[시간 복잡도]
개념: 프로그램이 실행되는 데 걸리는 시간이 입력 크기에 따라 어떻게 증가하는지를 나타냄
1. 시간 복잡도가 중요한 이유
-프로그램이 입력 크기가 커졌을 때도 빠르게 실행될지 예측할 수 있음
-느린 알고리즘을 선택하면 실행 시간이 너무 길어질 수 있음

2. 시간 복잡도를 이해하는 기본 원칙
(1) 가장 많이 반복되는 연산을 기준으로 생각하기
프로그램이 어떤 반복문을 실행하면 실행 시간이 증가함
반복문이 많을수록, 반복 횟수가 많을수록 시간이 더 오래 걸림

(2) 빅오 표기법 (O(n))
입력 크기(n)가 커질 때, 실행 시간이 증가하는 패턴을 나타내는 표기법
O(1), O(n), O(n²), O(log n), O(2ⁿ) 등이 있음

3. 주요 시간 복잡도 유형
시간 복잡도	의미	예시
O(1):	항상 일정한 시간이 걸림	배열에서 특정 위치 값 찾기
O(log n):	입력 크기가 커질수록 실행 시간이 천천히 증가	이진 탐색 (Binary Search)
O(n):	입력 크기에 비례해서 실행 시간이 증가	단순 반복문 (for i := 0; i < n; i++)
O(n²):	입력 크기 n이 커질수록 실행 시간이 제곱으로 증가	이중 반복문
O(2ⁿ):	입력 크기가 커질수록 실행 시간이 매우 빠르게 증가	재귀 함수 (피보나치)
