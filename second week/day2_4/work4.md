## ğŸ’¡ë¬¸ì œ ë¶„ì„ ìš”ì•½
ì¡°ê±´)
-í•˜ë£¨ì— í•˜ë‚˜ì˜ ìƒë‹´ë§Œ ê°€ëŠ¥
-ìƒë‹´ì„ ì‹œì‘í•˜ë©´ í•´ë‹¹ ê¸°ê°„(Ti) ë™ì•ˆ ë‹¤ë¥¸ ìƒë‹´ ì§„í–‰ ë¶ˆê°€
-N+1ì¼ ì´í›„ì—ëŠ” ìƒë‹´ ë¶ˆê°€

## ğŸ’¡ì•Œê³ ë¦¬ì¦˜ ì„¤ê³„

1.ì„ íƒì§€:
a)í˜„ì¬ ìƒë‹´ì„ ì§„í–‰í•˜ëŠ” ê²½ìš°
-day + T[day]ë¡œ ì´ë™í•˜ì—¬ ë‹¤ìŒ ìƒë‹´ íƒìƒ‰
-ì´ìµì€ P[day] ì¦ê°€
b)í˜„ì¬ ìƒë‹´ì„ ì§„í–‰í•˜ì§€ ì•ŠëŠ” ê²½ìš°
-day + 1ë¡œ ì´ë™í•˜ì—¬ ë‹¤ìŒ ìƒë‹´ íƒìƒ‰
-ì´ìµ ë³€ë™ ì—†ìŒ

2.dp[i] = max(dp[i+1], P[i] + dp[i+T[i]])
-p[i]ëŠ” iì¼ë¶€í„° í‡´ì‚¬ì¼ê¹Œì§€ ì–»ì„ ìˆ˜ ìˆëŠ” ìµœëŒ€ ì´ìµ
-dp[i+1]: iì¼ì˜ ìƒë‹´ì„ í•˜ì§€ ì•ŠëŠ” ê²½ìš°
-P[i] + dp[i+T[i]]: iì¼ì˜ ìƒë‹´ì„ ìˆ˜í–‰í•˜ëŠ” 

3.ì„¤ê³„
-dp ë°°ì—´ì„ ë’¤ì—ì„œë¶€í„° ì±„ìš°ë©° ìµœëŒ“ê°’ì„ ì €ì¥
-dp[i] = max(dp[i+1], P[i] + dp[i+T[i]])ë¥¼ ë°˜ë³µ


## ğŸ’¡ì½”ë“œ
`
package main

import (
	"fmt"
)

// ìµœëŒ€ ìƒë‹´ ìˆ˜ìµ ê³„ì‚° (DP ë°©ì‹)
func maxProfit(N int, T []int, P []int) int {
	dp := make([]int, N+1) // dp[i]: iì¼ë¶€í„° í‡´ì‚¬ì¼ê¹Œì§€ ì–»ì„ ìˆ˜ ìˆëŠ” ìµœëŒ€ ì´ìµ

	// ë’¤ì—ì„œë¶€í„° íƒìƒ‰
	for i := N - 1; i >= 0; i-- {
		if i+T[i] > N { // ìƒë‹´ ê¸°ê°„ì´ ë„˜ì–´ê°€ë©´
			dp[i] = dp[i+1]
		} else {
			dp[i] = max(dp[i+1], P[i]+dp[i+T[i]])
		}
	}

	return dp[0] // ì²«ë‚ ë¶€í„° ì‹œì‘í–ˆì„ ë•Œì˜ ìµœëŒ€ ì´ìµ
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func main() {
	var N int
	fmt.Scan(&N)

	T := make([]int, N)
	P := make([]int, N)

	for i := 0; i < N; i++ {
		fmt.Scan(&T[i], &P[i])
	}

	fmt.Println(maxProfit(N, T, P))
}
`

## ğŸ’¡ê°œë…
1. ì™„ì „ íƒìƒ‰ (Brute Force, DFS)
ëª¨ë“  ê²½ìš°ë¥¼ íƒìƒ‰í•˜ëŠ” ë°©ì‹
ì‘ì€ Nì—ì„œëŠ” ê°€ëŠ¥í•˜ì§€ë§Œ Nì´ í¬ë©´ ë¹„íš¨ìœ¨ì 

2.ë™ì  ê³„íšë²• (DP)
ì‘ì€ ë¬¸ì œë¥¼ í•´ê²°í•˜ë©´ì„œ ê²°ê³¼ë¥¼ ì €ì¥í•˜ê³  ì¬í™œìš©í•˜ëŠ” ê¸°ë²•
dp[i]ë¥¼ ë’¤ì—ì„œë¶€í„° ì±„ìš°ëŠ” Bottom-Up ë°©ì‹ ì‚¬ìš©
ì í™”ì‹: dp[i] = max(dp[i+1], P[i] + dp[i+T[i]])

3.ë°°ì—´ê³¼ ì¸ë±ìŠ¤ ê´€ë¦¬
Goì—ì„œëŠ” ë°°ì—´ì„ ìŠ¬ë¼ì´ìŠ¤(slice)ë¡œ ì„ ì–¸í•˜ê³  ì‚¬ìš©
dp ë°°ì—´ì„ N+1 í¬ê¸°ë¡œ ë§Œë“¤ì–´ì„œ ì´ˆê³¼ ê³„ì‚° ë°©ì§€

## ğŸ’¡ë‹¤ë¥¸ í’€ì´ ë°©ë²•: ë°ì´í„° êµ¬ì¡°ë¥¼ ë³€ê²½í•´ì„œ structë¥¼ í™œìš©(T, P)ìŒìœ¼ë¡œ ì €ì¥
- struct ì‚¬ìš©í•´ ë°ì´í„° ì €ì¥
- DFS(ì¬ê·€) + ë©”ëª¨ì´ì œì´ì…˜ìœ¼ë¡œ ì¤‘ë³µ ê³„ì‚°ì„ ì¤„ì´ê¸°
`
package main

import (
	"fmt"
)

// ìƒë‹´ ì •ë³´ë¥¼ ì €ì¥í•  êµ¬ì¡°ì²´
type Job struct {
	time int // ìƒë‹´ ì†Œìš” ê¸°ê°„
	pay  int // ìƒë‹´ ìˆ˜ìµ
}

var (
	N     int
	jobs  []Job
	memo  []int
)

// DFS + ë©”ëª¨ì´ì œì´ì…˜ ë°©ì‹ìœ¼ë¡œ ìµœëŒ€ ì´ìµ ê³„ì‚°
func dfs(day int) int {
	// í‡´ì‚¬ì¼ì„ ë„˜ì–´ê°€ë©´ ìƒë‹´ ë¶ˆê°€ëŠ¥
	if day >= N {
		return 0
	}

	// ì´ë¯¸ ê³„ì‚°ëœ ê°’ì´ë©´ ë°˜í™˜
	if memo[day] != -1 {
		return memo[day]
	}

	// í˜„ì¬ ìƒë‹´ì„ í•˜ì§€ ì•ŠëŠ” ê²½ìš°
	profit := dfs(day + 1)

	// í˜„ì¬ ìƒë‹´ì„ í•˜ëŠ” ê²½ìš° (í‡´ì‚¬ ì „ì— ìƒë‹´ì´ ëë‚˜ëŠ” ê²½ìš°ë§Œ)
	if day+jobs[day].time <= N {
		profit = max(profit, jobs[day].pay+dfs(day+jobs[day].time))
	}

	// ë©”ëª¨ì´ì œì´ì…˜
	memo[day] = profit
	return profit
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func main() {
	fmt.Scan(&N)

	jobs = make([]Job, N)
	memo = make([]int, N)

	// ë©”ëª¨ ë°°ì—´ì„ -1ë¡œ ì´ˆê¸°í™” (ë¯¸ë°©ë¬¸ í‘œì‹œ)
	for i := range memo {
		memo[i] = -1
	}

	// ìƒë‹´ ì •ë³´ ì…ë ¥
	for i := 0; i < N; i++ {
		fmt.Scan(&jobs[i].time, &jobs[i].pay)
	}

	// DFS íƒìƒ‰ ì‹œì‘
	fmt.Println(dfs(0))
}
`
ì •ë¦¬
1) êµ¬ì¡°ì²´ ì‚¬ìš©: struct job
-ë°ì´í„° ì ‘ê·¼ì´ ë” ì§ê´€ì ì´ë‹¤.
2) DFS+Memoization ì‚¬ìš©
- memo[day]ë¥¼ í™œìš©í•˜ì—¬ ì¤‘ë³µ ê³„ì‚°ì„ í”¼í•¨
- ì‹œê°„ ë³µì¡ë„ê°€ O(N)ìˆ˜ì¤€ìœ¼ë¡œ ì¤„ì–´ë“ ë‹¤.
3) ì¬ê·€(DFS)ì‚¬ìš©
- í‡´ì‚¬ì¼ì„ ë„˜ëŠ” ê²½ìš°ë¥¼ ì‰½ê²Œ ì²˜ë¦¬í•  ìˆ˜ ìˆë‹¤.
EX) if day >= N

